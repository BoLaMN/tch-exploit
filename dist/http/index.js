var ACME, Duplex, args, createHttpsServer, createServer, cwmp, duckdns, existsSync, file, path, readFileSync, ref, route, statSync;

Duplex = require('stream').Duplex;

createServer = require('http').createServer;

createHttpsServer = require('https').createServer;

ref = require('fs'), readFileSync = ref.readFileSync, existsSync = ref.existsSync, statSync = ref.statSync;

ACME = require('@root/acme');

duckdns = require('acme-dns-01-duckdns');

path = require('path');

file = require('./file');

route = require('./router');

args = require('../args');

cwmp = require('./cwmp');

module.exports = function(ip, port, url) {
  var acme, dns01, domain, e, srv;
  if (args.file) {
    file.name = path.basename(args.file);
    try {
      file.data = readFileSync(args.file);
    } catch (error) {
      e = error;
      throw e;
    }
  }
  file.data = Buffer.from(file.data).toString('utf8').replace('{{url}}', url, 'utf8');
  file.ext = path.extname(file.name);
  route.get("/" + file.name, function(req, res) {
    var ext, headers, stream;
    ext = file.ext.toUpperCase();
    console.log(">>> " + ext + " REQUEST");
    headers = {
      'Content-Type': 'text/plain',
      'Content-Length': file.data.length
    };
    console.log('>>> #{ ext } RESPONSE');
    console.dir([headers, file.data.toString('utf8')]);
    res.writeHead(200, headers);
    stream = new Duplex();
    stream.push(file.data);
    stream.push(null);
    stream.pipe(res).get('/done', function(req, res) {});
    console.log('>>> WPS CALLBACK');
    console.log("\n\nAll done,\n\n- change network card settings back to dhcp and move the cable back to a lan port\n- try ssh connection to the gateways ip (usually 192.168.0.1) with username root and password root (change password immediately with passwd!)\n\nssh root@192.168.0.1");
    setTimeout(function() {
      return process.exit(1);
    }, 20000);
    res.writeHead(200);
    return res.end().post('/', cwmp(url));
  });
  if (url.indexOf("https://") !== -1) {
    domain = new URL(url).hostname;
    if (args.duckdnstoken) {
      dns01 = duckdns.create({
        baseUrl: 'https://www.duckdns.org/update',
        token: args.duckdnstoken
      });
      console.log("Requesting HTTPS certificate to LE via duckdns...");
      require('http-request').get('https://www.duckdns.org/update?domains=' + domain + '&token=' + args.duckdnstoken + '&ip=' + ip, function(err, res) {
        if (err) {
          return console.log("Error updating duckdns domain IP!!!");
        }
      });
    } else {
      console.log("No duckdns token!!");
    }
    acme = ACME.create({
      maintainerEmail: 'test@gmail.com',
      packageAgent: 'tch-exploit/v1.0'
    });
    acme.init('https://acme-v02.api.letsencrypt.org/directory').then(function(r) {
      var Keypairs;
      Keypairs = require('@root/keypairs');
      return Keypairs.generate({
        kty: 'EC',
        format: 'jwk'
      }).then(function(accountKeypair) {
        return acme.accounts.create({
          subscriberEmail: 'test1@gmail.com',
          agreeToTerm: true,
          accountKey: accountKeypair["private"]
        }).then(function(account) {
          return Keypairs.generate({
            kty: 'RSA',
            format: 'jwk'
          }).then(function(serverKeypair) {
            return Keypairs["export"]({
              jwk: serverKeypair["private"]
            }).then(function(privateKey) {
              var CSR, PEM, punycode;
              CSR = require('@root/csr');
              PEM = require('@root/pem');
              punycode = require('punycode');
              return CSR.csr({
                jwk: serverKeypair["private"],
                domains: [punycode.toASCII(domain)],
                encoding: 'der'
              }).then(function(csrDer) {
                var csr;
                csr = PEM.packBlock({
                  type: 'CERTIFICATE REQUEST',
                  bytes: csrDer
                });
                return acme.certificates.create({
                  account: account,
                  accountKey: accountKeypair["private"],
                  csr: csr,
                  domains: [domain],
                  challenges: {
                    'dns-01': dns01
                  }
                }).then(function(pems) {
                  var srv;
                  console.log("HTTPS certificate received!");
                  console.log(privateKey);
                  console.log("Cert:");
                  console.log(pems.chain);
                  srv = createHttpsServer(route);
                  srv.options = {
                    key: privateKey,
                    cert: pems.chain
                  };
                  if (port === 80) {
                    port = 443;
                  }
                  srv.keepAliveTimeout = 30000;
                  srv.on('error', function(e) {
                    var ref1;
                    if ((ref1 = e.code) === 'EADDRINUSE' || ref1 === 'EADDRNOTAVAIL') {
                      console.log(e.code + ', retrying...');
                      return setTimeout(function() {
                        srv.close();
                        return srv.listen(port);
                      }, 1000);
                    } else {
                      return console.error(e);
                    }
                  });
                  srv.listen(port);
                  return console.log("Started HTTPS server...");
                });
              });
            });
          });
        });
      });
    });
  } else {
    srv = createServer(route);
    srv.keepAliveTimeout = 30000;
    srv.on('error', function(e) {
      var ref1;
      if ((ref1 = e.code) === 'EADDRINUSE' || ref1 === 'EADDRNOTAVAIL') {
        console.log(e.code + ', retrying...');
        return setTimeout(function() {
          srv.close();
          return srv.listen(port);
        }, 1000);
      } else {
        return console.error(e);
      }
    });
    srv.listen(port);
  }
  return srv;
};
