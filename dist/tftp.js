var ProgressIndicator, Transform, createServer, createTFTPStream, dhcp, fs, ips, path,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

createServer = require('tftp').createServer;

Transform = require('stream').Transform;

dhcp = require('./dhcp/server');

ips = require('./ips')();

ProgressIndicator = (function(superClass) {
  extend(ProgressIndicator, superClass);

  function ProgressIndicator(size, options) {
    this.size = size;
    ProgressIndicator.__super__.constructor.call(this, options);
    this.last = 0;
    this.bytes = 0;
  }

  ProgressIndicator.prototype._transform = function(chunk, encoding, cb) {
    var percent;
    this.bytes += chunk.length;
    percent = this.bytes / this.size * 100 | 0;
    if ((percent % 5) === 0 && percent !== this.last) {
      this.last = percent;
      this.emit('progress', {
        percent: percent,
        loaded: this.bytes,
        total: this.size
      });
    }
    cb(null, chunk);
  };

  return ProgressIndicator;

})(Transform);

createTFTPStream = function(res, tftp) {
  var done, firmwareStream, prog, stats;
  stats = fs.statSync(tftp);
  res.setSize(stats.size);
  firmwareStream = fs.createReadStream(tftp);
  console.log('Sending firmware to router...');
  prog = new ProgressIndicator(stats.size);
  done = false;
  prog.on('progress', function(arg) {
    var p, percent;
    percent = arg.percent;
    p = Math.round(percent * 100) / 100;
    if (p % 10 === 0) {
      console.log('Sent: ' + p + '%');
    }
    if (percent >= 100) {
      if (done) {
        return;
      }
      console.log('Firmware sent! Now just wait for the router to reboot');
      firmwareStream.close();
      done = true;
    }
  });
  return firmwareStream.pipe(prog).pipe(res);
};

module.exports = function(arg) {
  var addr, dhcpd, eth, ip, network, server, tftp;
  eth = arg.eth, ip = arg.ip, tftp = arg.tftp;
  if (eth != null) {
    network = ips.find(function(arg1) {
      var name;
      name = arg1.name;
      return name === eth;
    });
  }
  if (ip == null) {
    ip = network != null ? network.address : void 0;
  }
  addr = ip.split('.');
  addr.pop();
  addr = addr.join('.');
  dhcpd = dhcp.createServer({
    range: [addr + '.10', addr + '.15'],
    forceOptions: ['router', 'hostname', 'bootFile'],
    randomIP: true,
    netmask: '255.255.255.0',
    router: [ip],
    hostname: 'second.gateway',
    broadcast: addr + '.255',
    bootFile: function(req, res) {
      console.log(req, res);
      return path.basename(tftp);
    },
    server: ip
  }).on('listening', function(sock, type) {
    var address, port, ref;
    ref = sock.address(), address = ref.address, port = ref.port;
    return console.log("Waiting for DHCP" + type + " request... " + address + ":" + port);
  }).on('message', function(data) {
    return console.log('### MESSAGE', JSON.stringify(data));
  }).on('bound', function(state, ans) {
    return console.log('### BOUND', JSON.stringify(state));
  }).on('error', function(err, data) {
    if (!data) {
      return;
    }
    return console.log('!!! ERROR', err, data);
  }).listen(67);
  server = createServer({
    host: '0.0.0.0',
    port: 69,
    denyPUT: true
  }, function(req, res) {
    var file;
    console.log('Received tftp request from', req.stats.remoteAddress, 'for file', req.file);
    if (req.file) {
      file = path.join(tftp, req.file);
      createTFTPStream(res, file);
    } else {
      createTFTPStream(res, tftp);
    }
    return req.on('error', function(err) {
      return console.error('ERROR:', err);
    });
  });
  server.on('error', function(err) {
    return console.error('ERROR:', err);
  });
  console.log('Starting tftp server, listening on ' + ip + ':69');
  server.listen();
  return [dhcpd, server];
};
