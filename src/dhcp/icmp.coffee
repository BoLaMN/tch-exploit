raw = require('raw-socket')
net = require('net')
dns = require('dns')


{ EventEmitter } = require 'events'

class ICMP extends EventEmitter
  @createSocket: (options) ->
    new ICMP options

  constructor: (@host) ->
    super()

    @ip = ''

    @socket = raw.createSocket
      protocol: raw.Protocol.ICMPv6
      addressFamily: raw.AddressFamily.IPv6

    @open = false
    @type = ''
    @code = ''

  close: () ->
      @socket.close()

      if @_timeout
          clearTimeout @_timeout

  _resolveIP:() ->
    new Promise (resolve, reject) =>
      if not @ip
        if net.isIPv4 @host
          @ip = @host

          return resolve()

      dns.resolve4 @host, (err, ips) =>
        if err
          return reject(err)

        @ip = ips[0]

        resolve()

  _queue: (header, timeout = 5000) ->
    new Promise (resolve, reject) =>
      @socket.on 'error', (err) ->
        reject err

        send = ->
          @socket.send header, 0, header.length, @ip, (err, source) =>
            if err
              return reject err

            console.log 'ip', source

            @_timeout = setTimeout() =>
              resolve()
              @close()
            , timeout

            @start = process.hrtime()

            @socket.on 'message', (buffer, source) =>
              console.log 'ip', source, @ip
              if source is @ip
                NS_PER_SEC = 1e9

                @diff = process.hrtime(@start)
                @elapsed = (@diff[0] + @diff[1] / NS_PER_SEC) * 1000

                offset = 20

                type = buffer.readUInt8(offset)
                code = buffer.readUInt8(offset + 1)

                @parse(type, code)
                @close()

                resolve()

        @_resolveIP()
          .then send
          .catch reject

  createHeader: (data) ->
    datastr = String data

    header = Buffer.alloc(8 + datastr.length)
    header.fill(0, 8)

    header.writeUInt8(8, 0)
    header.writeUInt8(0, 1)
    header.writeUInt16BE(0, 2)

    header.writeUInt16LE(process.pid % 65535, 4)
    header.write(datastr, 8)

    raw.writeChecksum header, 2, raw.createChecksum(header)

  send: (data = "", timeout = 5000) ->
    header = @createHeader data

    @_queue header, timeout

  @send: (host, data = "", timeout = 5000) ->
    obj = new ICMP host


    obj.send data, timeout
      .then -> obj

  ping: (timeout = 5000) ->
    @send '', @timeout

  @ping: (host, timeout = 5000) ->
    @send host, '', timeout

  _error: (error) ->
    @emit 'error', error

  _close: ->
    @emit 'close'

  _message: (buffer, source) ->
    @emit 'message', buffer, source

  bind: (cb = (buffer, source) ->) ->
    @socket.on 'error', @_error.bind @
    @socket.on 'close', @_close.bind @
    @socket.on 'message', @_message.bind @

    console.log 'bound raw-socket'

    cb()

  parse: (type, code) ->
    ECHOMessageType = ['REPLY', 'NA', 'NA', 'DESTINATION_UNREACHABLE', 'SOURCE_QUENCH', 'REDIRECT']
    DestinationUnreachableCode = ['NET', 'HOST', 'PROTOCOL', 'PORT', 'FRAGMENTATION', 'ROUTE_FAILED', 'NET_UNKNOWN', 'HOST_UNKNOWN', 'HOST_ISOLATED', 'NET_PROHIBITED', 'HOST_PROHIBITED', 'NET_UNREACHABLE', 'HOST_UNREACHABLE', 'COMM_PROHIBITED', 'HOST_PRECEDENCE', 'PRECEDENCE_CUTOFF']
    RedirectCode = ['NETWORK', 'HOST', 'SERVICE_NETWORK', 'HOST_NETWORK']

    @type = 'OTHER'
    @code = 'NO_CODE'

    @open = not type

    if type < ECHOMessageType.length
      @type = ECHOMessageType[type]

    @code = switch type
      when 3 then DestinationUnreachableCode[code]
      when 5 then RedirectCode[code]

    { @type, @code, @open }

module.exports = ICMP

