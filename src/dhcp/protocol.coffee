SeqBuffer = require './seqbuffer'

{ DHCPV6 } = require './constants'

module.exports =
  parse: (buf) ->
    if buf.length < 230
      throw new Error 'Received data is too short'

    sb = new SeqBuffer buf

    op: sb.getUInt8()
    htype: htype = sb.getUInt8()
    hlen: hlen = sb.getUInt8()
    hops: sb.getUInt8()
    xid: sb.getUInt32()
    secs: sb.getUInt16()
    flags: sb.getUInt16()
    ciaddr: sb.getIP()
    yiaddr: sb.getIP()
    siaddr: sb.getIP()
    giaddr: sb.getIP()
    chaddr: sb.getMAC(htype, hlen)
    sname: sb.getUTF8(64)
    file: sb.getUTF8(128)
    magicCookie: sb.getUInt32()
    options: sb.getOptions()

  format: (data) ->
    sb = new SeqBuffer

    sb.addUInt8 data.op
    sb.addUInt8 data.htype
    sb.addUInt8 data.hlen
    sb.addUInt8 data.hops
    sb.addUInt32 data.xid
    sb.addUInt16 data.secs
    sb.addUInt16 data.flags
    sb.addIP data.ciaddr
    sb.addIP data.yiaddr
    sb.addIP data.siaddr
    sb.addIP data.giaddr
    sb.addMac data.chaddr
    sb.addUTF8Pad data.sname, 64
    sb.addUTF8Pad data.file, 128
    sb.addUInt32 0x63825363
    sb.addOptions data.options
    sb.addUInt8 255

    sb

  parseIpv6: (msg, rinfo) ->
    options = { op: msg.readUInt8(0) }

    offset = 0

    readAddressRaw = (msg, offset, len) ->
      addr = ''

      while len-- > 0
        b = msg.readUInt8(offset++)
        addr += (b + 0x100).toString(16).substr(-2)

        if len > 0
          addr += ':'

      addr

    if options.op is 12
      hopCount = msg.readUInt8(1)
      linkAddress = ''

      i = 2

      while i < 18
        if i != 2
          linkAddress = linkAddress + ':'

        linkHex = msg.readUInt16BE(i).toString(16)

        linkPre = switch linkHex.length
          when 3 then '0'
          when 2 then '00'
          when 1 then '000'
          else ''

        linkAddress = linkAddress + linkPre + linkHex

        i = i + 2

      linkAddress = linkAddress
      peerAddress = ''

      o = 18

      while o < 34
        if o != 18
          peerAddress = peerAddress + ':'

        peerHex = msg.readUInt16BE(o).toString(16)

        peerPre = switch peerHex.length
          when 3 then '0'
          when 2 then '00'
          when 1 then '000'
          else ''

        peerAddress = peerAddress + peerPre + peerHex

        o = o + 2

      peerAddress = peerAddress

      offset = 33
    else
      xid = msg.readUInt8(1).toString(16) + msg.readUInt8(2).toString(16) + msg.readUInt8(3).toString(16)

      options.xid = switch xid.length
        when 1 then '00000' + xid
        when 2 then '0000' + xid
        when 3 then '000' + xid
        when 4 then '00' + xid
        when 5 then '0' + xid

      offset = 3

    while offset < msg.length - 1
      optionCode = msg.readInt16BE(offset + 1)
      optionLen = msg.readInt16BE(offset + 3)

      offset = offset + 4

      switch optionCode
        when 1
          DUIDType = msg.readUInt16BE(offset + 1)
          iBuf = new Buffer(optionLen)

          msg.copy iBuf, 0, offset + 1, offset + 1 + optionLen

          options.clientIdentifierOption = switch DUIDType
            when 1
              buffer: iBuf
              DUIDType: DUIDType
              hardwareType: msg.readUInt16BE(offset + 3)
              time: msg.readUInt32BE(offset + 5)
              linkLayerAddress: readAddressRaw(msg, offset + 9, optionLen - 8)
            when 2
              buffer: iBuf
              DUIDType: DUIDType
              enterpriseNumber: undefined
              enterpriseNumberContd: undefined
              identifier: undefined
            when 3
              buffer: iBuf
              DUIDType: DUIDType
              hardwareType: msg.readUInt16BE(offset + 3)
              linkLayerAddress: readAddressRaw(msg, offset + 5, optionLen - 4)

          offset += optionLen

          break
        when 2
          DUIDType = msg.readUInt16BE(offset + 1)
          iBuf = new Buffer(optionLen)

          msg.copy iBuf, 0, offset + 1, offset + 1 + optionLen

          options.serverIdentifierOption = switch DUIDType
            when 1
              buffer: iBuf
              DUIDType: DUIDType
              hardwareType: msg.readUInt16BE(offset + 3)
              time: msg.readUInt32BE(offset + 5)
              linkLayerAddress: readAddressRaw(msg, offset + 9, optionLen - 8)
            when 2
              buffer: iBuf
              DUIDType: DUIDType
              enterpriseNumber: undefined
              enterpriseNumberContd: undefined
              identifier: undefined
            when 3
              buffer: iBuf
              DUIDType: DUIDType
              hardwareType: msg.readUInt16BE(offset + 3)
              linkLayerAddress: readAddressRaw(msg, offset + 5, optionLen - 4)

          offset += optionLen

          break
        when 3
          options.IA_NA =
            IAID: msg.readUInt32BE(offset + 1)
            T1: msg.readUInt32BE(offset + 5)
            T2: msg.readUInt32BE(offset + 9)

          offset += optionLen

          break
        when 6
          options.request = []
          options.requestDesc = []

          i6 = 1

          while i6 < optionLen
            num = msg.readUInt16BE(offset + i6)
            prot = protocol.DHCPv6OptionsCode.get(num)

            if prot and prot.name
              options.requestDesc.push prot.name

            options.request.push num

            i6 = i6 + 2

          offset += optionLen

          break
        when 8
          options.elapsedTime = msg.readUInt16BE(offset + 1)

          offset += optionLen

          break
        when 9
          relayBuf = new Buffer(optionLen)
          msg.copy relayBuf, 0, offset + 1, offset + 1 + optionLen

          options.dhcpRelayMessage = parser6.parse(relayBuf, rinfo)

          offset += optionLen

          break
        when 18
          interfaceID = new Buffer(optionLen)

          msg.copy interfaceID, 0, offset + 1, offset + 1 + optionLen

          options.interfaceID =
            hex: msg.toString('hex', offset + 1, offset + 1 + optionLen)
            buffer: interfaceID

          offset += optionLen

          break
        when 25
          options.IA_PD =
            IAID: msg.readUInt32BE(offset + 1)
            T1: msg.readUInt32BE(offset + 5)
            T2: msg.readUInt32BE(offset + 9)

          offset += optionLen

          break
        when 37
          options.relayAgentRemoteID =
            enterpriseNumber: msg.readUInt32BE(offset + 1)
            remoteId: msg.toString('hex', offset + 5, offset + 1 + optionLen)

          offset += optionLen

          break
        when 39
          options.clientFQDN =
            flags: msg.readUInt8(offset + 1)
            domainName: msg.toString('utf8', offset + 2, offset + 1 + optionLen)

          offset += optionLen

          break
        else
          codeName = DHCPV6.OPTIONS[optionCode]

          console.log 'Unhandled DHCPv6 option ' + optionCode + ' (' + codeName + ')/' + optionLen + 'b'

          offset += optionLen

          break

    options
