{ Parser } = require 'binary-parser-encoder'

decodeIpv6Buffer = (arr) ->
  buffer = Buffer.from arr
  result = []

  i = 0

  while i < buffer.length
    result.push buffer.readUInt16BE(i).toString 16
    i += 2

  result
    .join ':'
    .replace /(^|:)0(:0)*:0(:|$)/, '$1::$3'
    .replace /:{3,4}/, '::'

ipv6PseudoHeader = new Parser()
  .endianess 'big'
  .array 'SourceAddress',
    type: 'uint8',
    length: 16
    formatter: decodeIpv6Buffer
  .array 'DestinationAddress',
    type: 'uint8',
    length: 16
    formatter: decodeIpv6Buffer
  .uint32 'Length'
  .array 'Zeros',
    type: 'uint8',
    length: 3
  .uint8 'NextHeader'

ipv6Hdr = new Parser()
  .endianess 'big'
  .array 'VTF',
    type: 'uint8'
    length: 4
  .uint16 'PayloadLength'
  .uint8 'NextHeader'
  .uint8 'HopLimit'
  .array 'SourceAddress',
    type: 'uint8'
    length: 16
  .array 'DestinationAddress',
    type: 'uint8'
    length: 16

ipv6Option = new Parser()
  .endianess 'big'
  .uint8 'NextHeader'
  .uint8 'Length'
  .string 'Data',
    encoding: 'hex'
    length: 'Length'

ipv4Hdr = new Parser()
  .endianess 'big'
  .bit4 'Version'
  .bit4 'IHL'
  .uint8 'TypeOfService'
  .uint16 'TotalLength'
  .uint16 'Identification'
  .bit3 'Flags'
  .bit13 'FragmentOffset'
  .uint8 'TimeToLIve'
  .uint8 'Protocol'
  .uint16 'HeaderChecksum'
  .array 'SourceAddress',
    type: 'uint8'
    length: 4
  .array 'DestinationAddress',
    type: 'uint8'
    length: 4

ipv4Option = new Parser()
  .endianess 'big'
  .uint8 'Type'
  .uint8 'Length'
  .uint16 'Data'

parseIpv4 = (data) ->
  ipv4Hdr.parse data

parseIpv6 = (data) ->
  ipv6Hdr.parse data

encodeIpv4 = (ipHeader, options) ->
  ipHdrBuff = ipv4Hdr.encode ipHeader

  ipOptionsBuff = Buffer.alloc 0

  if options
    ipOptionsBuff = ipv4Option.encode options

  ipBuff = Buffer.concat [
    ipHdrBuff
    ipOptionsBuff
  ]

  ipHeaderWithChecksum = undefined

  if !ipHeader.HeaderChecksum
    ip = (new Parser).array('data',
      type: 'uint16be'
      length: ipBuff.length / 2)
    ipPacket = ip  .parse ipBuff

    # Checksum calculation
    i = 0
    sum = 0

    while i < ipPacket.data.length
      sum += ipPacket.data[i++]
      a = sum.toString 16

      if a.length > 4
        sum = parseInt(a[1] + a[2] + a[3] + a[4], 16) + 1

    a = (~sum >>> 0).toString 16
    sum = parseInt(a[4] + a[5] + a[6] + a[7], 16)

    ipHeaderWithChecksum = Object.assign ipHeader
    ipHeaderWithChecksum.HeaderChecksum = sum

  ipv4Hdr.encode ipHeaderWithChecksum

encodeIpv6 = (ipHeader) ->
  ipv6Hdr.encode ipHeader

parseIpv6Option = (header) ->
  ipv6Option.parse header

encodeIpv6Pseudo = (header) ->
  ipv6PseudoHeader.encode header

exports.parseIpv4 = parseIpv4
exports.parseIpv6 = parseIpv6

exports.encodeIpv4 = encodeIpv4
exports.encodeIpv6 = encodeIpv6

exports.parseIpv6Option = parseIpv6Option
exports.encodeIpv6Pseudo = encodeIpv6Pseudo

exports.decodeIpv6Buffer = decodeIpv6Buffer