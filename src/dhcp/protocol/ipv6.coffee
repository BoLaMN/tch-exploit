{ Parser } = require 'binary-parser-encoder'

ipv6PseudoHeader = new Parser()
  .endianess 'big'
  .array 'SourceAddress',
    type: 'uint8',
    length: 16
    formatter: decodeIPV6Buffer
  .array 'DestinationAddress',
    type: 'uint8',
    length: 16
    formatter: decodeIPV6Buffer
  .uint32 'Length'
  .array 'Zeros',
    type: 'uint8',
    length: 3
  .uint8 'NextHeader'

encodeIpv6Pseudo = (header) -> ipv6PseudoHeader.encode(header)

decodeIPV6Buffer = (arr) ->
  buffer = Buffer.from arr
  result = []

  i = 0

  while i < buffer.length
    result.push buffer.readUInt16BE(i).toString 16
    i += 2

  result
    .join ':'
    .replace /(^|:)0(:0)*:0(:|$)/, '$1::$3'
    .replace /:{3,4}/, '::'

RouterSolicitation = new Parser()
  .uint32 'Reserved'

AutoConfigFlags = new Parser()
  .bit1 'R'
  .bit1 'S'
  .bit1 'O'
  .bit29 'Reserved'

Flags = new Parser()
  .bit1 'M'
  .bit1 'O'
  .bit6 'Reserved'

RouterAdvertisement = new Parser()
  .uint8 'CurrentHopLimit'
  .nest 'Flags',
    type: Flags
  .uint16 'RouterLifetime'
  .uint32 'ReachableTime'
  .uint32 'RetransTimer'
  .buffer 'Options',
    readUntil: 'eof'

NeighbourSolicitation = new Parser()
  .uint32 'Reserved'
  .array 'TargetAddress',
    type: 'uint8'
    length: 16
    formatter: decodeIPV6Buffer
  .uint8 'Options'

NeighbourAdvertisement = new Parser()
  .nest 'AutoConfigFlags',
    type: AutoConfigFlags
  .array 'TargetAddress',
    type: 'uint8'
    length: 16
    formatter: decodeIPV6Buffer

Redirect = new Parser()
  .uint32 'Reserved'
  .array 'TargetAddress',
    type: 'uint8'
    length: 16
    formatter: decodeIPV6Buffer

MulticastListener = new Parser()
  .uint32 'Reserved'
  .uint16 'MulticastRecords'

icmp = new Parser()
  .uint8 'Type'
  .uint8 'Code'
  .uint16 'Checksum'
  .choice
    tag: 'Type'
    choices:
      133: RouterSolicitation
      134: RouterAdvertisement
      135: NeighbourSolicitation
      136: NeighbourAdvertisement
      137: Redirect
      143: MulticastListener

MulticastAddressRecords = new Parser()
  .uint8 'Type'
  .uint8 'AuxDataLen'
  .uint16 'NumberOfSources'
  .array 'MulticastAddress',
    type: 'uint8'
    length: 16
    formatter: decodeIPV6Buffer

module.exports =

  parse: (data) ->
    icmpPacket = icmp.parse(data)

    if icmpPacket.Type == 143
      totalRecords = icmpPacket.MulticastRecords

      i = 0
      records = []

      while i < totalRecords
        records.push MulticastAddressRecords.parse(data.slice(8 + i * 20))
        i++

      icmpPacket.MulticastRecords = records

    icmpPacket

  format: (icmpHeader, ipv6Pseudo, multicastRecords) ->
    icmpBuff = icmp.encode(icmpHeader)

    if icmpHeader.Type == 143
      recordsBuff = MulticastAddressRecords.encode(multicastRecords)

      icmpBuff = Buffer.concat([
        icmpBuff
        recordsBuff
      ])

    # Calculating Checksum and adding it in packet
    if !icmpHeader.Checksum
      ipv6PseudoBuff = encodeIpv6Pseudo(ipv6Pseudo)

      icmpChecksumBuffer = Buffer.concat([
        ipv6PseudoBuff
        icmpBuff
      ])

      icmpParser = new Parser()
        .array 'data',
          type: 'uint16be'
          length: icmpChecksumBuffer.length / 2

      icmpPacket = icmpParser.parse(icmpChecksumBuffer)

      # Checksum calculation
      i = 0
      sum = 0

      a = undefined

      while i < icmpPacket.data.length
        sum += icmpPacket.data[i++]
        a = sum.toString(16)

        if a.length > 4
          sum = parseInt(a[1] + a[2] + a[3] + a[4], 16) + 1

      a = (~sum >>> 0).toString(16)

      # Invert bitwise and unsign the number
      sum = parseInt(a[4] + a[5] + a[6] + a[7], 16)

      # Taking 2 bytes out of the inverted bytes
      icmpHeaderWithChecksum = Object.assign(icmpHeader)
      icmpHeaderWithChecksum.Checksum = sum

      icmpBuff = @format(icmpHeaderWithChecksum, ipv6Pseudo, multicastRecords)

    icmpBuff
