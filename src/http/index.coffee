{Duplex} = require 'stream'
{createServer} = require 'http'
createHttpsServer = require('https').createServer
{readFileSync, existsSync, statSync} = require 'fs'
ACME = require '@root/acme'
duckdns = require 'acme-dns-01-duckdns'

path = require 'path'

file = require './file'
route = require './router'
args = require '../args'
cwmp = require './cwmp'

module.exports = (ip, port, url) ->
  if args.file
    file.name = path.basename args.file

    try
      file.data = readFileSync args.file
    catch e
      throw e

  file.data = Buffer.from file.data
    .toString 'utf8'
    .replace '{{url}}', url
  , 'utf8'

  file.ext = path.extname file.name

  route
    .get "/#{file.name}", (req, res) ->
      ext = file.ext.toUpperCase()

      console.log ">>> #{ ext } REQUEST"

      headers =
        'Content-Type': 'text/plain'
        'Content-Length': file.data.length

      console.log '>>> #{ ext } RESPONSE'
      console.dir [headers, file.data.toString('utf8')]

      res.writeHead 200, headers

      stream = new Duplex()
      stream.push file.data
      stream.push null
      stream.pipe res
      .get '/done', (req, res) ->
      console.log '>>> WPS CALLBACK'
      console.log """\n
          All done,

          - change network card settings back to dhcp and move the cable back to a lan port
          - try ssh connection to the gateways ip (usually 192.168.0.1) with username root and password root (change password immediately with passwd!)

          ssh root@192.168.0.1"""

      setTimeout ->
        process.exit 1
      , 20000

      res.writeHead 200
      res.end()

      .post '/', cwmp(url)
  if(url.indexOf("https://") isnt -1)

    domain = new URL(url).hostname
    if(args.duckdnstoken)
      dns01 = duckdns.create({
          baseUrl: 'https://www.duckdns.org/update',
          token: args.duckdnstoken
      });
      console.log("Requesting HTTPS certificate to LE via duckdns...")
      require('http-request').get('https://www.duckdns.org/update?domains='+domain+'&token='+args.duckdnstoken+'&ip='+ip, (err, res) ->
          if (err)
            console.log("Error updating duckdns domain IP!!!")
        );
    else
      console.log("No duckdns token!!")
    acme = ACME.create({ maintainerEmail:'test@gmail.com', packageAgent:'tch-exploit/v1.0' })
    acme.init('https://acme-v02.api.letsencrypt.org/directory').then((r) ->
      Keypairs = require('@root/keypairs');
      Keypairs.generate({ kty: 'EC', format: 'jwk' }).then((accountKeypair) ->
        acme.accounts.create({
          subscriberEmail:'test1@gmail.com',
          agreeToTerm:true,
          accountKey:accountKeypair.private
        }).then((account) ->
          Keypairs.generate({ kty: 'RSA', format: 'jwk' }).then((serverKeypair) ->
            Keypairs.export({ jwk: serverKeypair.private }).then((privateKey) ->
              CSR = require('@root/csr')
              PEM = require('@root/pem')
              punycode = require('punycode')
              CSR.csr({ jwk: serverKeypair.private, domains: [punycode.toASCII(domain)], encoding:'der' }).then((csrDer) ->
                csr = PEM.packBlock({ type: 'CERTIFICATE REQUEST', bytes: csrDer });
                acme.certificates.create({
                  account: account,
                  accountKey: accountKeypair.private,
                  csr: csr,
                  domains: [domain],
                  challenges: { 'dns-01': dns01 }
                }).then( (pems) ->
                  console.log("HTTPS certificate received!")
                  console.log(privateKey)
                  console.log("Cert:")
                  console.log(pems.chain)
                  srv = createHttpsServer route
                  srv.options = {
                    key: privateKey,
                    cert: pems.chain
                  }
                  if (port == 80)
                    port = 443
                  srv.keepAliveTimeout = 30000

                  srv.on 'error', (e) ->
                    if e.code in ['EADDRINUSE', 'EADDRNOTAVAIL']
                      console.log e.code + ', retrying...'

                      setTimeout ->
                        srv.close()
                        srv.listen port
                      , 1000
                    else console.error e

                  srv.listen port
                  console.log("Started HTTPS server...")
                )
              )
            )
          )
        )
      )
    )
  else
    srv = createServer route
    srv.keepAliveTimeout = 30000

    srv.on 'error', (e) ->
      if e.code in ['EADDRINUSE', 'EADDRNOTAVAIL']
        console.log e.code + ', retrying...'

        setTimeout ->
          srv.close()
          srv.listen port
        , 1000
      else console.error e

    srv.listen port

  srv
